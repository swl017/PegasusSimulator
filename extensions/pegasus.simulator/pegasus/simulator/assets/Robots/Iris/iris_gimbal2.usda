#usda 1.0
(
    customLayerData = {
        dictionary cameraSettings = {
            dictionary Front = {
                double3 position = (5, 0, 0)
                double radius = 5
            }
            dictionary Perspective = {
                double3 position = (0.9587793654809456, 0.8442009837024987, 0.6442056656101973)
                double3 target = (0.006406921423632417, -0.0017165768796826297, -0.010203000158071629)
            }
            dictionary Right = {
                double3 position = (0, -5, 0)
                double radius = 5
            }
            dictionary Top = {
                double3 position = (0, 0, 5)
                double radius = 5
            }
            string boundCamera = "/OmniverseKit_Persp"
        }
        dictionary omni_layer = {
            string authoring_layer = "./iris_gimbal2.usda"
            dictionary locked = {
            }
            dictionary muteness = {
            }
        }
        dictionary renderSettings = {
            double "rtx:post:lensFlares:flareScale" = 0.075
            float3 "rtx:sceneDb:ambientLightColor" = (0, 0, 0)
        }
    }
    defaultPrim = "Robot"
    endTimeCode = 1000000
    metersPerUnit = 1
    startTimeCode = 0
    timeCodesPerSecond = 60
    upAxis = "Z"
)

def Xform "Robot"
{
    def "iris" (
        prepend references = @./iris.usd@
    )
    {
        float3 xformOp:rotateXYZ = (0, 0, 0)
        float3 xformOp:scale = (1, 1, 1)
        double3 xformOp:translate = (0, 0, 0.2)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]

        def Xform "yaw_link" (
            apiSchemas = ["PhysicsArticulationLinkAPI", "PhysicsMassAPI", "PhysicsRigidBodyAPI", "PhysxRigidBodyAPI"]
        )
        {
            bool physics:kinematicEnabled = 0
            quatd xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:scale = (1, 1, 1)
            double3 xformOp:translate = (0, 0, -0.05)
            # double3 xformOp:translate = (0.1, 0, -0.04999999999999999)
            point3f physics:centerOfMass = (0, 0, 0)
            float3 physics:diagonalInertia = (0.00000001, 0.00000001, 0.00000001)
            float physics:mass = 0.001
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

            def PhysicsRigidBody "YawRigidBody"
            {
                bool physics:kinematicEnabled = 0
            }

            def PhysicsRevoluteJoint "yaw_joint" (
                apiSchemas = ["PhysxJointAPI", "PhysicsJointStateAPI:angular", "PhysicsDriveAPI:angular"]
            )
            {
                uniform token physics:axis = "Z"
                rel physics:body0 = </Robot/iris/body/body>
                rel physics:body1 = </Robot/iris/yaw_link>
                float physics:breakForce = inf
                float physics:breakTorque = inf
                point3f physics:localPos0 = (9.0695113e-7, -0.1, -0.049999993)
                point3f physics:localPos1 = (1.4901161e-9, 0, 5.9604646e-9)
                quatf physics:localRot0 = (0.70711, 0, 0, -0.70710355)
                quatf physics:localRot1 = (1, 0, 0, 0)
            }
        }

        def Xform "roll_link" (
            apiSchemas = ["PhysicsArticulationLinkAPI", "PhysicsMassAPI", "PhysicsRigidBodyAPI", "PhysxRigidBodyAPI"]
        )
        {
            bool physics:kinematicEnabled = 0
            quatd xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:scale = (1, 1, 1)
            double3 xformOp:translate = (0, 0, -0.05)
            # double3 xformOp:translate = (0.1, 0, -0.04999999999999999)
            point3f physics:centerOfMass = (0, 0, 0)
            float3 physics:diagonalInertia = (0.00000001, 0.00000001, 0.00000001)
            float physics:mass = 0.001
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

            def PhysicsRigidBody "RollRigidBody"
            {
                bool physics:kinematicEnabled = 0
            }

            def PhysicsRevoluteJoint "roll_joint" (
                apiSchemas = ["PhysxJointAPI", "PhysicsJointStateAPI:angular", "PhysicsDriveAPI:angular"]
            )
            {
                uniform token physics:axis = "X"
                rel physics:body0 = </Robot/iris/yaw_link/YawRigidBody>
                rel physics:body1 = </Robot/iris/roll_link>
                float physics:breakForce = inf
                float physics:breakTorque = inf
                point3f physics:localPos0 = (1.4901161e-9, 0, 5.9604646e-9)
                point3f physics:localPos1 = (1.4901161e-9, 0, 5.9604646e-9)
                quatf physics:localRot0 = (1, 0, 0, 0)
                quatf physics:localRot1 = (1, 0, 0, 0)
            }
        }

        def Xform "pitch_link" (
            apiSchemas = ["PhysicsArticulationLinkAPI", "PhysicsMassAPI", "PhysicsRigidBodyAPI", "PhysxRigidBodyAPI"]
        )
        {
            bool physics:kinematicEnabled = 0
            quatd xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:scale = (1, 1, 1)
            double3 xformOp:translate = (0, 0, -0.05)
            # double3 xformOp:translate = (0.1, 0, -0.04999999999999999)
            point3f physics:centerOfMass = (0, 0, 0)
            float3 physics:diagonalInertia = (0.00000001, 0.00000001, 0.00000001)
            float physics:mass = 0.001
                        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

            def PhysicsRigidBody "PitchRigidBody"
            {
                bool physics:kinematicEnabled = 0
            }

            def PhysicsRevoluteJoint "pitch_joint" (
                apiSchemas = ["PhysxJointAPI", "PhysicsJointStateAPI:angular", "PhysicsDriveAPI:angular"]
            )
            {
                uniform token physics:axis = "Y"
                rel physics:body0 = </Robot/iris/roll_link/RollRigidBody>
                rel physics:body1 = </Robot/iris/pitch_link>
                float physics:breakForce = inf
                float physics:breakTorque = inf
                point3f physics:localPos0 = (1.4901161e-9, 0, 5.9604646e-9)
                point3f physics:localPos1 = (1.4901161e-9, 0, 5.9604646e-9)
                quatf physics:localRot0 = (1, 0, 0, 0)
                quatf physics:localRot1 = (1, 0, 0, 0)
            }

            def Camera "camera"
            {
                float2 clippingRange = (0.01, 10000000)
                float focalLength = 18.147562
                float focusDistance = 400
                token visibility = "invisible"
                quatd xformOp:orient = (0.5, 0.5, -0.5, -0.5)
                double3 xformOp:scale = (1, 1, 1)
                double3 xformOp:translate = (0, 0, 0)
                uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]
            }
        }
    }

    def OmniGraph "PushGraph"
    {
        token evaluationMode = "Automatic"
        token evaluator:type = "push"
        token fabricCacheBacking = "Shared"
        int2 fileFormatVersion = (1, 9)
        token pipelineStage = "pipelineStageSimulation"

        def OmniGraphNode "pitch_linkCurveNode"
        {
            custom string inputs:IndividualOutputs
            custom rel inputs:Prim = </Robot/iris/pitch_link> (
                customData = {
                    dictionary omni = {
                        dictionary graph = {
                            string relType = "target"
                        }
                    }
                }
            )
            custom timecode inputs:Time
            custom bool inputs:UseGlobalTime
            token node:type = "omni.anim.curve.core.AnimCurve"
            int node:typeVersion = 5
            custom rel outputs_AnimFrame (
                customData = {
                    dictionary omni = {
                        dictionary graph = {
                            string relType = "bundle"
                        }
                    }
                }
            )
            uniform token visibility:x:defaultTangentType = "auto"
            uniform int64[] visibility:x:inTangentTimes = [0]
            uniform token[] visibility:x:inTangentTypes = ["auto"]
            uniform double[] visibility:x:inTangentValues = [0]
            uniform int64[] visibility:x:outTangentTimes = [0]
            uniform token[] visibility:x:outTangentTypes = ["step"]
            uniform double[] visibility:x:outTangentValues = [0]
            uniform token visibility:x:postInfinityType = "constant"
            uniform token visibility:x:preInfinityType = "constant"
            uniform bool[] visibility:x:tangentBrokens = [0]
            uniform bool[] visibility:x:tangentWeighteds = [0]
            uniform int64[] visibility:x:times = [0]
            uniform double[] visibility:x:values = [0]
            uniform token xformOp:scale:x:defaultTangentType = "auto"
            uniform int64[] xformOp:scale:x:inTangentTimes = [0]
            uniform token[] xformOp:scale:x:inTangentTypes = ["auto"]
            uniform double[] xformOp:scale:x:inTangentValues = [0]
            uniform int64[] xformOp:scale:x:outTangentTimes = [0]
            uniform token[] xformOp:scale:x:outTangentTypes = ["auto"]
            uniform double[] xformOp:scale:x:outTangentValues = [0]
            uniform token xformOp:scale:x:postInfinityType = "constant"
            uniform token xformOp:scale:x:preInfinityType = "constant"
            uniform bool[] xformOp:scale:x:tangentBrokens = [0]
            uniform bool[] xformOp:scale:x:tangentWeighteds = [0]
            uniform int64[] xformOp:scale:x:times = [0]
            uniform double[] xformOp:scale:x:values = [1]
            uniform token xformOp:scale:y:defaultTangentType = "auto"
            uniform int64[] xformOp:scale:y:inTangentTimes = [0]
            uniform token[] xformOp:scale:y:inTangentTypes = ["auto"]
            uniform double[] xformOp:scale:y:inTangentValues = [0]
            uniform int64[] xformOp:scale:y:outTangentTimes = [0]
            uniform token[] xformOp:scale:y:outTangentTypes = ["auto"]
            uniform double[] xformOp:scale:y:outTangentValues = [0]
            uniform token xformOp:scale:y:postInfinityType = "constant"
            uniform token xformOp:scale:y:preInfinityType = "constant"
            uniform bool[] xformOp:scale:y:tangentBrokens = [0]
            uniform bool[] xformOp:scale:y:tangentWeighteds = [0]
            uniform int64[] xformOp:scale:y:times = [0]
            uniform double[] xformOp:scale:y:values = [1]
            uniform token xformOp:scale:z:defaultTangentType = "auto"
            uniform int64[] xformOp:scale:z:inTangentTimes = [0]
            uniform token[] xformOp:scale:z:inTangentTypes = ["auto"]
            uniform double[] xformOp:scale:z:inTangentValues = [0]
            uniform int64[] xformOp:scale:z:outTangentTimes = [0]
            uniform token[] xformOp:scale:z:outTangentTypes = ["auto"]
            uniform double[] xformOp:scale:z:outTangentValues = [0]
            uniform token xformOp:scale:z:postInfinityType = "constant"
            uniform token xformOp:scale:z:preInfinityType = "constant"
            uniform bool[] xformOp:scale:z:tangentBrokens = [0]
            uniform bool[] xformOp:scale:z:tangentWeighteds = [0]
            uniform int64[] xformOp:scale:z:times = [0]
            uniform double[] xformOp:scale:z:values = [1]
            uniform token xformOp:translate:x:defaultTangentType = "auto"
            uniform int64[] xformOp:translate:x:inTangentTimes = [0]
            uniform token[] xformOp:translate:x:inTangentTypes = ["auto"]
            uniform double[] xformOp:translate:x:inTangentValues = [0]
            uniform int64[] xformOp:translate:x:outTangentTimes = [0]
            uniform token[] xformOp:translate:x:outTangentTypes = ["auto"]
            uniform double[] xformOp:translate:x:outTangentValues = [0]
            uniform token xformOp:translate:x:postInfinityType = "constant"
            uniform token xformOp:translate:x:preInfinityType = "constant"
            uniform bool[] xformOp:translate:x:tangentBrokens = [0]
            uniform bool[] xformOp:translate:x:tangentWeighteds = [0]
            uniform int64[] xformOp:translate:x:times = [0]
            uniform double[] xformOp:translate:x:values = [0.1]
            uniform token xformOp:translate:y:defaultTangentType = "auto"
            uniform int64[] xformOp:translate:y:inTangentTimes = [0]
            uniform token[] xformOp:translate:y:inTangentTypes = ["auto"]
            uniform double[] xformOp:translate:y:inTangentValues = [0]
            uniform int64[] xformOp:translate:y:outTangentTimes = [0]
            uniform token[] xformOp:translate:y:outTangentTypes = ["auto"]
            uniform double[] xformOp:translate:y:outTangentValues = [0]
            uniform token xformOp:translate:y:postInfinityType = "constant"
            uniform token xformOp:translate:y:preInfinityType = "constant"
            uniform bool[] xformOp:translate:y:tangentBrokens = [0]
            uniform bool[] xformOp:translate:y:tangentWeighteds = [0]
            uniform int64[] xformOp:translate:y:times = [0]
            uniform double[] xformOp:translate:y:values = [0]
            uniform token xformOp:translate:z:defaultTangentType = "auto"
            uniform int64[] xformOp:translate:z:inTangentTimes = [0]
            uniform token[] xformOp:translate:z:inTangentTypes = ["auto"]
            uniform double[] xformOp:translate:z:inTangentValues = [0]
            uniform int64[] xformOp:translate:z:outTangentTimes = [0]
            uniform token[] xformOp:translate:z:outTangentTypes = ["auto"]
            uniform double[] xformOp:translate:z:outTangentValues = [0]
            uniform token xformOp:translate:z:postInfinityType = "constant"
            uniform token xformOp:translate:z:preInfinityType = "constant"
            uniform bool[] xformOp:translate:z:tangentBrokens = [0]
            uniform bool[] xformOp:translate:z:tangentWeighteds = [0]
            uniform int64[] xformOp:translate:z:times = [0]
            uniform double[] xformOp:translate:z:values = [-0.04999999999999999]
        }
    }
}

# def Xform "Environment"
# {
#     int ground:size = 1400
#     string ground:type = "On"
#     quatd xformOp:orient = (1, 0, 0, 0)
#     double3 xformOp:scale = (1, 1, 1)
#     double3 xformOp:translate = (0, 0, 0)
#     uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

#     def DomeLight "Sky" (
#         prepend apiSchemas = ["ShapingAPI"]
#     )
#     {
#         float inputs:colorTemperature = 6250
#         bool inputs:enableColorTemperature = 1
#         float inputs:exposure = 9
#         float inputs:intensity = 1
#         float inputs:shaping:cone:angle = 180
#         float inputs:shaping:cone:softness
#         float inputs:shaping:focus
#         color3f inputs:shaping:focusTint
#         asset inputs:shaping:ies:file
#         asset inputs:texture:file = @../../../../../../../../../isaacsim/extscache/omni.kit.stage_templates-1.2.6+d02c707b/data/CarLight_512x256.hdr@
#         token inputs:texture:format = "latlong"
#         token visibility = "inherited"
#         quatd xformOp:orient = (1, 0, 0, 0)
#         double3 xformOp:rotateXYZ = (0, 0, 0)
#         double3 xformOp:scale = (1, 1, 1)
#         double3 xformOp:translate = (0, 0, 305)
#         uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
#     }

#     def DistantLight "DistantLight" (
#         prepend apiSchemas = ["ShapingAPI"]
#     )
#     {
#         float inputs:angle = 2.5
#         float inputs:colorTemperature = 7250
#         bool inputs:enableColorTemperature = 1
#         float inputs:exposure = 10
#         float inputs:intensity = 1
#         float inputs:shaping:cone:angle = 180
#         float inputs:shaping:cone:softness
#         float inputs:shaping:focus
#         color3f inputs:shaping:focusTint
#         asset inputs:shaping:ies:file
#         token visibility = "inherited"
#         quatd xformOp:orient = (0.6532814824381883, 0.2705980500730985, 0.27059805007309845, 0.6532814824381882)
#         double3 xformOp:rotateXYZ = (-15, 0, 0)
#         double3 xformOp:scale = (1, 1, 1)
#         double3 xformOp:translate = (0, 0, 305)
#         uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
#     }

#     def Scope "Looks"
#     {
#         def Material "Grid"
#         {
#             token outputs:mdl:displacement.connect = </Environment/Looks/Grid/Shader.outputs:out>
#             token outputs:mdl:surface.connect = </Environment/Looks/Grid/Shader.outputs:out>
#             token outputs:mdl:volume.connect = </Environment/Looks/Grid/Shader.outputs:out>

#             def Shader "Shader"
#             {
#                 uniform token info:implementationSource = "sourceAsset"
#                 uniform asset info:mdl:sourceAsset = @OmniPBR.mdl@
#                 uniform token info:mdl:sourceAsset:subIdentifier = "OmniPBR"
#                 float inputs:albedo_add = 0
#                 float inputs:albedo_brightness = 0.52
#                 float inputs:albedo_desaturation = 1
#                 asset inputs:diffuse_texture = @../../../../../../../../../isaacsim/extscache/omni.kit.stage_templates-1.2.6+d02c707b/data/ov_uv_grids_basecolor_1024.png@ (
#                     colorSpace = "sRGB"
#                     customData = {
#                         asset default = @@
#                     }
#                 )
#                 bool inputs:project_uvw = 0
#                 float inputs:reflection_roughness_constant = 0.333
#                 float inputs:texture_rotate = 0 (
#                     customData = {
#                         float default = 0
#                     }
#                 )
#                 float2 inputs:texture_scale = (0.5, 0.5) (
#                     customData = {
#                         float2 default = (1, 1)
#                     }
#                 )
#                 float2 inputs:texture_translate = (0, 0) (
#                     customData = {
#                         float2 default = (0, 0)
#                     }
#                 )
#                 bool inputs:world_or_object = 0 (
#                     customData = {
#                         bool default = 0
#                     }
#                 )
#                 token outputs:out (
#                     renderType = "material"
#                 )
#             }
#         }
#     }

#     def Mesh "ground" (
#         prepend apiSchemas = ["MaterialBindingAPI"]
#     )
#     {
#         float3[] extent = [(-50, -50, 0), (50, 50, 0)]
#         int[] faceVertexCounts = [4]
#         int[] faceVertexIndices = [0, 1, 3, 2]
#         rel material:binding = </Environment/Looks/Grid> (
#             bindMaterialAs = "weakerThanDescendants"
#         )
#         normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1)] (
#             interpolation = "faceVarying"
#         )
#         point3f[] points = [(-50, -50, 0), (50, -50, 0), (-50, 50, 0), (50, 50, 0)]
#         texCoord2f[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1)] (
#             interpolation = "faceVarying"
#         )
#         uniform token subdivisionScheme = "none"
#         quatd xformOp:orient = (1, 0, 0, 0)
#         double3 xformOp:rotateXYZ = (0, 0, 0)
#         double3 xformOp:scale = (1, 1, 1)
#         double3 xformOp:translate = (0, 0, 0)
#         uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
#     }

#     def Plane "groundCollider" (
#         prepend apiSchemas = ["PhysicsCollisionAPI"]
#     )
#     {
#         uniform token axis = "Z"
#         uniform token purpose = "guide"
#     }
# }

